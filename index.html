<html>
  <head>
    <title>Michael Mattie's GitHub Site</title>
    <style>
      body { 
        background: rgb(137, 161, 199);
        padding: 10px;
	margin: 0px;
	border: 4px solid black;
      }

      h1,h2,h3 { text-align: center; }

      .box {
        margin: 10px;
	margin-bottom: 1em;
	padding: 1em;

	background: white;
        box-shadow: 10px 10px;
      }

      #portrait {
        width: 25%;
	height: 30%;

	display: float;
	float: left;

	margin-right: 8px;
	margin-bottom: 8px;
      }
    </style>
  </head>
  <body>
    <div id="intro" class="box">
      <img id="portrait" src="selfie.jpg"/>

      <h1>Michael Mattie - Senior Software Engineer</h1>
      <h2><a href="http://www.linkedin.com/in/mike-mattie">LinkedIn</a></h2>

      <h2>Introduction</h2>

      <p>
	I am Michael Mattie, a Senior Software Engineer on the West
	Coast. I love programming: particularly in Python and LISP.
	Professionally I like working on the backend at scale.
      </p>

      <p>
	Here are some of my code samples and projects. Most of the
	samples are gists since they are only a file or two and not
	really intended for collaberation. Peruse the menu below.
      </p>

      <h2>Languages, Data Structures, and Algorithms examples</h2>
      <ul>
	<li><a href="#heapsort">[Language: Python] - heapsort algorithm with 3 variations</a></li>
	<li><a href="#mergesort">[Language: Common Lisp] - merge-sort with queues</a></li>
	<li><a href="#futuretask">[Language: Java] - FutureTask concurrency using a background worker queue</a></li>
	<li><a href="#rc">[Language: Perl5] - version control wrapper</a></li>
	<li><a href="#parser">[Language: Elisp] - PEG Grammar parser compiler</a></li>
	<li><a href="#verify">[Language: State Diagram] - Program Verification</a></li>
	<li><a href="#fd_alloc">[Language: shell] - fd_alloc allocator (featured in diagram)</a></li>
	<li><a href="#language">[Language: Clojure] - Natural language pattern matching based on keywords</a></li>
	<li><a href="#sedify">[UNIX] - process C++ source with sed</a></li>
      </ul>
    </div>

    <div id="heapsort" class="box">
      <h2>[Python] - heapsort algorithm with 3 variations</h2>
      <h3><a href="https://gist.github.com/coderofmattie/b14734fe00988a1a5b5683d984917d0e">heapsort.py on GitHub</a></h3>

      <p>
	I was investigating the Heap Sort algorithm for sorting in
	place with heaps. During my implementation of the algorithm
	from Essential Algorithms by Rod Stephens I discovered that
	the book's algorithm was producing broken heaps. I was able to
	modify the algorithm and correct the problem, but I found that
	even with other algorithms such as the Wikipedia/MIT version
	there were still broken heaps.
      </p>

      <p>
	My heapsort.py implements the three versions and benchmarks
	them. My conclusion is that the broken heaps are tolerated in
	the MIT version which pushes values down, but not in the
	Essential Algorithms which pushes values up.
      </p>
    </div>


    <div id="mergesort" class="box">
      <h2>[Common Lisp] merge-sort with queues</h2>
      <h3><a href="https://gist.github.com/coderofmattie/fc1c8fd252ddd8699a375fd1dd6cab77">merge-sort.lisp on GitHub</a></h3>
      <p>
	I decided to implement the merge-sort algorithm as it looked
	like the first algorithm that was LISP friendly since it
	consisted of merging lists. I also wrote common lisp for the
	first time.
      </p>

      <p>
	The algorithm worked when I implemented it but the performance
	seemed terrible. I analyzed the algorithm and determined that
	the operations like append that work at the end of lists are
	O(n) for every operation. I wrote a queue implementation that
	resulted in a 44x speedup, and memery usage went from 1.5Gb to
	2Mb.
      </p>

      <p>
	Here is the difference on a sort of 10,000 elements.
      </p>

      <pre>
DEFAULT LIBRARY FUNCTIONS

merge-sort.lisp -> running now
Evaluation took:
  0.402 seconds of real time
  0.401896 seconds of total run time (0.374674 user, 0.027222 system)
  [ Run times consist of 0.012 seconds GC time, and 0.390 seconds non-GC time. ]
  100.00% CPU
  888,749,204 processor cycles
  1,599,489,264 bytes consed
  
sorted = to long to print

MY QUEUE FUNCTIONS

merge-sort.lisp -> running now
Evaluation took:
  0.009 seconds of real time
  0.008828 seconds of total run time (0.008275 user, 0.000553 system)
  100.00% CPU
  19,489,098 processor cycles
  2,752,416 bytes consed
  
sorted = to long to print
      </pre>
    </div>

    <div id="futuretask" class="box">
      <h2>[Java] FutureTask concurrency using a background worker queue</h2>
      <h3><a href="https://gist.github.com/coderofmattie/92dd9562145d0bee0dbf87d170e94087">FutureTask.java on GitHub</a></h3>

      <p>
	FutureTask was the implementation of a library interface for
	running tasks that complete at some time in the future. I
	wrote it so you could instantiate a task and it would schedule
	it for execution in a worker queue implementation in the class
	static.
      </p>
    </div>

    <div id="rc" class="box">
      <h2>[Perl5] version control wrapper</h2>
      <h3><a href="https://gist.github.com/coderofmattie/b301c920fd2ddaaaf24d46833ca15f9a">rc.pl on GitHub</a></h3>

      <p>
	rc is a wrapper around version control systems that I wrote
	because I was using so many different version control systems
	including git, darcs, and perforce at the time. It references
	"Fault" a library not provided that classified exceptions and
	provided a general mechanism for handling them.
      </p>
    </div>

    <div id="parser" class="box">
      <h2>[Elisp] PEG grammer parser compiler</h2>
      <h3><a href="https://gist.github.com/coderofmattie/d5fe4e8a2fb11b03d5de218c7d4c6e79">parser.el on GitHub</a></h3>

      <p>
	parser.el is a project from my early LISP days to create a
	parser compiler in ELisp. It used a number of advanced
	techniques such as macros, co-routines, and greedy packing of
	symbol streams to implement a PEG compiler that produces code
	that looks human written.
      </p>
    </div>

    <div id="verify" class="box">
      <h2>Program Verification Diagram of the fd allocator written in shell</h2>

      <p>
	I was attempting to do some program verification on some shell
	code and I wrote this diagram defining the states of the
	program and the transitions along with constraints on
	variables in the states.
      </p>

      <img src="fd_alloc.png"/>
    </div>

    <div id="fd_alloc" class="box">
      <h2>fd_alloc file handle allocator/manager written in shell</h2>
      <h3><a href="https://gist.github.com/coderofmattie/8e76a7b7d4e345470976385b146ed93c">fd_alloc.sh on GitHub</a></h3>
      <p>
	A sophisticated byte-compiled Z shell library for allocating
	file handles for regular processes and co-processes.
      </p>
    </div>

    <div id="language" class="box">
      <h2>Natural Language Processing in Clojure</h2>
      <h3><a href="https://gist.github.com/coderofmattie/fda0532e6e854bbf8b359790e66a0cf7">language.clj on GitHub</a></h3>

      <p>
	I worked on naturual language parsing in a project to perform
	banking actions via SMS. The project never took off but I
	learned alot about clojure.
      </p>
    </div>


    <div id="sedify" class="box">
      <h2>sedify-C++ in sed</h2>
      <h3><a href="https://gist.github.com/coderofmattie/919d96ac32044a882ec8022c49ae4ddf">sedify-C++.sh on GitHub</a></h3>

      <p>
	I needed to make some edits in mulitple files so I devised a
	scheme to run them through sed and make the necessary changes
	with one script. This is the result.
      </p>
    </div>
  </body>
</html>
